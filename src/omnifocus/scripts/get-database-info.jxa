(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // Direct property access is faster and more reliable in OmniFocus 4
      const value = obj[prop];
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      return defaultValue;
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const doc = app.defaultDocument;
    
    // Get basic database info
    const databaseInfo = {
      name: safeGet(doc, 'name') || 'OmniFocus Database',
      path: safeGet(doc, 'file') ? safeGet(doc, 'file').toString() : 'Unknown',
      isDefault: true,
      statistics: {
        tasks: {
          total: 0,
          available: 0,
          completed: 0,
          dropped: 0,
          blocked: 0,
          flagged: 0
        },
        projects: {
          total: 0,
          active: 0,
          onHold: 0,
          completed: 0,
          dropped: 0,
          flagged: 0
        },
        tags: {
          total: 0
        },
        folders: {
          total: 0
        }
      },
      lastUpdated: new Date().toISOString()
    };
    
    // Count tasks with error handling
    try {
      const allTasks = safeGet(doc, 'flattenedTasks');
      if (allTasks) {
        databaseInfo.statistics.tasks.total = allTasks.length;
      
      let availableCount = 0, completedCount = 0, droppedCount = 0, blockedCount = 0, flaggedCount = 0;
      
      for (let i = 0; i < allTasks.length; i++) {
        try {
          const task = allTasks[i];
          
          // Check completion status
          if (safeGet(task, 'completed', false)) {
            completedCount++;
          } else if (safeGet(task, 'dropped', false)) {
            droppedCount++;
          } else if (safeGet(task, 'blocked', false)) {
            blockedCount++;
          } else {
            availableCount++;
          }
          
          // Check flagged status
          if (safeGet(task, 'flagged', false)) {
            flaggedCount++;
          }
        } catch (e) {
          // Skip tasks that can't be accessed
          continue;
        }
      }
      
        databaseInfo.statistics.tasks.available = availableCount;
        databaseInfo.statistics.tasks.completed = completedCount;
        databaseInfo.statistics.tasks.dropped = droppedCount;
        databaseInfo.statistics.tasks.blocked = blockedCount;
        databaseInfo.statistics.tasks.flagged = flaggedCount;
      }
    } catch (e) {
      // If task counting fails, leave at 0
    }
    
    // Count projects with error handling
    try {
      const allProjects = safeGet(doc, 'flattenedProjects');
      if (allProjects) {
        databaseInfo.statistics.projects.total = allProjects.length;
      
      let activeCount = 0, onHoldCount = 0, completedCount = 0, droppedCount = 0, flaggedCount = 0;
      
      for (let i = 0; i < allProjects.length; i++) {
        try {
          const project = allProjects[i];
          
          // Check project status
          const status = safeGet(project, 'status', 'active');
          if (status === 'active') {
            activeCount++;
          } else if (status === 'on hold') {
            onHoldCount++;
          } else if (status === 'completed') {
            completedCount++;
          } else if (status === 'dropped') {
            droppedCount++;
          }
          
          // Check flagged status
          if (safeGet(project, 'flagged', false)) {
            flaggedCount++;
          }
        } catch (e) {
          // Skip projects that can't be accessed
          continue;
        }
      }
      
        databaseInfo.statistics.projects.active = activeCount;
        databaseInfo.statistics.projects.onHold = onHoldCount;
        databaseInfo.statistics.projects.completed = completedCount;
        databaseInfo.statistics.projects.dropped = droppedCount;
        databaseInfo.statistics.projects.flagged = flaggedCount;
      }
    } catch (e) {
      // If project counting fails, leave at 0
    }
    
    // Count tags with error handling
    try {
      const allTags = safeGet(doc, 'flattenedTags');
      if (allTags) {
        databaseInfo.statistics.tags.total = allTags.length;
      }
    } catch (e) {
      // If tag counting fails, leave at 0
    }
    
    // Count folders with error handling
    try {
      const allFolders = safeGet(doc, 'flattenedFolders');
      if (allFolders) {
        databaseInfo.statistics.folders.total = allFolders.length;
      }
    } catch (e) {
      // If folder counting fails, leave at 0
    }
    
    return JSON.stringify(databaseInfo);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();