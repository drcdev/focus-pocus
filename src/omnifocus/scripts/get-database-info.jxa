(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const doc = app.defaultDocument;
    
    // Get basic database info
    const databaseInfo = {
      name: safeGet(doc, 'name') || 'OmniFocus Database',
      path: safeGet(doc, 'file') ? safeGet(doc, 'file').toString() : 'Unknown',
      isDefault: true,
      statistics: {
        tasks: {
          total: 0,
          available: 0,
          completed: 0,
          dropped: 0,
          blocked: 0,
          flagged: 0
        },
        projects: {
          total: 0,
          active: 0,
          onHold: 0,
          completed: 0,
          dropped: 0,
          flagged: 0
        },
        tags: {
          total: 0
        },
        folders: {
          total: 0
        }
      },
      lastUpdated: new Date().toISOString()
    };
    
    // Get task statistics more efficiently - avoid full iteration
    try {
      const allTasks = safeGet(doc, 'flattenedTasks');
      if (allTasks) {
        // Only get total count - avoid expensive iterations
        try {
          databaseInfo.statistics.tasks.total = allTasks.length;
        } catch (e) {
          // If .length fails, estimate by sampling first 100 tasks
          let sampleCount = 0;
          for (let i = 0; i < 100; i++) {
            try {
              if (allTasks[i]) sampleCount++;
              else break;
            } catch (e) {
              break;
            }
          }
          databaseInfo.statistics.tasks.total = sampleCount > 0 ? `~${sampleCount * 10}+` : 'Unknown';
        }
        
        // For detailed statistics, use efficient filtering instead of full iteration
        // This limits the performance impact
        try {
          // Sample only first 500 tasks for statistics to avoid timeout
          let sampleSize = Math.min(500, databaseInfo.statistics.tasks.total || 500);
          let availableCount = 0, completedCount = 0, flaggedCount = 0;
          let processed = 0;
          
          for (let i = 0; i < sampleSize && processed < 500; i++) {
            try {
              const task = allTasks[i];
              if (!task) break;
              
              processed++;
              
              if (safeGet(task, 'completed', false)) {
                completedCount++;
              } else {
                availableCount++;
              }
              
              if (safeGet(task, 'flagged', false)) {
                flaggedCount++;
              }
            } catch (e) {
              continue;
            }
          }
          
          // Estimate based on sample if we have a large database
          const scaleFactor = processed > 0 ? (databaseInfo.statistics.tasks.total / processed) : 1;
          databaseInfo.statistics.tasks.available = Math.round(availableCount * scaleFactor);
          databaseInfo.statistics.tasks.completed = Math.round(completedCount * scaleFactor);
          databaseInfo.statistics.tasks.flagged = Math.round(flaggedCount * scaleFactor);
          
          if (processed < databaseInfo.statistics.tasks.total) {
            databaseInfo.note = 'Statistics estimated from sample for performance';
          }
        } catch (e) {
          // Leave detailed stats at 0 if sampling fails
        }
      }
    } catch (e) {
      // If task counting fails, leave at 0
    }
    
    // Get project statistics efficiently
    try {
      const allProjects = safeGet(doc, 'flattenedProjects');
      if (allProjects) {
        try {
          databaseInfo.statistics.projects.total = allProjects.length;
        } catch (e) {
          databaseInfo.statistics.projects.total = 'Unknown';
        }
        
        // Sample projects for detailed statistics to avoid timeout
        try {
          let sampleSize = Math.min(100, databaseInfo.statistics.projects.total || 100);
          let activeCount = 0, completedCount = 0, flaggedCount = 0;
          let processed = 0;
          
          for (let i = 0; i < sampleSize && processed < 100; i++) {
            try {
              const project = allProjects[i];
              if (!project) break;
              
              processed++;
              
              const status = safeGet(project, 'status', 'active');
              if (status.includes('active')) {
                activeCount++;
              } else if (status.includes('completed') || status.includes('done')) {
                completedCount++;
              }
              
              if (safeGet(project, 'flagged', false)) {
                flaggedCount++;
              }
            } catch (e) {
              continue;
            }
          }
          
          // Estimate if needed
          const scaleFactor = processed > 0 ? (databaseInfo.statistics.projects.total / processed) : 1;
          databaseInfo.statistics.projects.active = Math.round(activeCount * scaleFactor);
          databaseInfo.statistics.projects.completed = Math.round(completedCount * scaleFactor);
          databaseInfo.statistics.projects.flagged = Math.round(flaggedCount * scaleFactor);
        } catch (e) {
          // Leave detailed stats at 0 if sampling fails
        }
      }
    } catch (e) {
      // If project counting fails, leave at 0
    }
    
    // Get tag and folder counts efficiently
    try {
      const allTags = safeGet(doc, 'flattenedTags');
      if (allTags) {
        try {
          databaseInfo.statistics.tags.total = allTags.length;
        } catch (e) {
          databaseInfo.statistics.tags.total = 'Unknown';
        }
      }
    } catch (e) {
      // If tag counting fails, leave at 0
    }
    
    try {
      const allFolders = safeGet(doc, 'flattenedFolders');
      if (allFolders) {
        try {
          databaseInfo.statistics.folders.total = allFolders.length;
        } catch (e) {
          databaseInfo.statistics.folders.total = 'Unknown';
        }
      }
    } catch (e) {
      // If folder counting fails, leave at 0
    }
    
    return JSON.stringify(databaseInfo);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();