(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const projectId = {{projectId}};
    const updates = {{updates}};
    const doc = app.defaultDocument;
    
    const project = doc.flattenedProjects.byId(projectId);
    if (!project || !project.id) {
      throw new Error('Project not found');
    }
    
    // Apply updates safely
    if (updates.name !== undefined) {
      project.name = updates.name;
    }
    if (updates.note !== undefined) {
      project.note = updates.note;
    }
    if (updates.status !== undefined) {
      // Handle status updates - some statuses require special methods
      if (updates.status === 'done status') {
        project.markComplete();
      } else if (updates.status === 'dropped status') {
        project.markDropped();
      } else {
        // Direct assignment works for 'active status' and 'on hold status'
        project.status = updates.status;
      }
    }
    if (updates.flagged !== undefined) {
      project.flagged = updates.flagged;
    }
    if (updates.dueDate !== undefined) {
      project.dueDate = updates.dueDate ? new Date(updates.dueDate) : null;
    }
    if (updates.deferDate !== undefined) {
      project.deferDate = updates.deferDate ? new Date(updates.deferDate) : null;
    }
    if (updates.sequential !== undefined) {
      project.sequential = updates.sequential;
    }
    if (updates.estimatedMinutes !== undefined) {
      project.estimatedMinutes = updates.estimatedMinutes || null;
    }
    
    // Update folder/container if provided
    if (updates.folderId !== undefined) {
      try {
        if (updates.folderId === null || updates.folderId === 'null') {
          // Move to root
          project.container = doc;
        } else {
          // Move to specific folder
          const targetFolder = doc.flattenedFolders.byId(updates.folderId);
          if (targetFolder) {
            project.container = targetFolder;
          } else {
            throw new Error('Target folder not found: ' + updates.folderId);
          }
        }
      } catch (e) {
        throw new Error('Failed to update project folder: ' + e.message);
      }
    }
    
    // Update review interval if provided
    if (updates.reviewInterval) {
      try {
        project.reviewInterval = {
          unit: updates.reviewInterval.unit,
          steps: updates.reviewInterval.steps
        };
      } catch (e) {
        // Review interval update might fail
      }
    }
    
    // Update tags if provided
    if (updates.tags !== undefined) {
      try {
        const tags = [];
        for (const tagId of updates.tags) {
          const tag = doc.flattenedTags.byId(tagId);
          if (tag) tags.push(tag);
        }
        project.tags = tags;
      } catch (e) {
        // Tag update might fail
      }
    }
    
    // Build result with safe property access
    const result = {
      folderId: null,
      taskCount: 0,
      availableTaskCount: 0,
      tags: []
    };
    
    // Use safeGet for reliable property access
    result.id = safeGet(project, 'id');
    result.name = safeGet(project, 'name', 'Unknown Project');
    result.note = safeGet(project, 'note', '');
    result.status = safeGet(project, 'status');
    result.flagged = safeGet(project, 'flagged', false);
    result.dueDate = safeDate(safeGet(project, 'dueDate'));
    result.deferDate = safeDate(safeGet(project, 'deferDate'));
    result.completionDate = safeDate(safeGet(project, 'completionDate'));
    result.sequential = safeGet(project, 'sequential', false);
    result.estimatedMinutes = safeGet(project, 'estimatedMinutes');
    
    // Get folder ID safely
    const container = safeGet(project, 'container');
    if (container && safeGet(container, 'class') === 'folder') {
      result.folderId = safeGet(container, 'id');
    }
    
    // Get task counts safely
    const tasks = safeGet(project, 'tasks');
    if (tasks) {
      result.taskCount = tasks.length || 0;
    }
    
    const availableTasks = safeGet(project, 'availableTasks');
    if (availableTasks) {
      result.availableTaskCount = availableTasks.length || 0;
    }
    
    // Get tags safely
    const projectTags = safeGet(project, 'tags');
    if (projectTags && projectTags.length > 0) {
      for (let i = 0; i < projectTags.length; i++) {
        const tag = projectTags[i];
        const tagData = {
          id: safeGet(tag, 'id'),
          name: safeGet(tag, 'name', 'Unknown Tag')
        };
        if (tagData.id || tagData.name !== 'Unknown Tag') {
          result.tags.push(tagData);
        }
      }
    }
    
    return JSON.stringify(result);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();