(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const taskId = {{taskId}};
    const targetProjectId = {{targetProjectId}};
    
    if (!taskId) {
      throw new Error('Task ID is required');
    }
    
    const doc = app.defaultDocument;
    
    // Find the task - with retry for newly created tasks
    let task = null;
    let attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts && !task) {
      try {
        task = doc.flattenedTasks.byId(taskId);
        if (task && task.id()) {
          break; // Found the task
        }
      } catch (e) {
        // Task not found, may need to wait for sync
      }
      
      attempts++;
      if (attempts < maxAttempts) {
        // Wait 500ms before retry
        app.delay(0.5);
      }
    }
    
    if (!task) {
      return JSON.stringify({
        error: true,
        message: `Task not found after ${maxAttempts} attempts: ${taskId}`,
        code: 'NOT_FOUND'
      });
    }
    
    // Move the task
    if (targetProjectId === null) {
      // Move to inbox - recreate as inbox task
      try {
        const taskProps = {
          name: task.name(),
          note: task.note() || '',
          flagged: task.flagged(),
          completed: task.completed()
        };
        
        // Copy optional properties if they exist
        try { if (task.dueDate()) taskProps.dueDate = task.dueDate(); } catch (e) {}
        try { if (task.deferDate()) taskProps.deferDate = task.deferDate(); } catch (e) {}
        try { if (task.estimatedMinutes()) taskProps.estimatedMinutes = task.estimatedMinutes(); } catch (e) {}
        try { if (task.completionDate()) taskProps.completionDate = task.completionDate(); } catch (e) {}
        
        // Create new inbox task
        const newTask = app.InboxTask(taskProps);
        doc.inboxTasks.push(newTask);
        
        // Copy tags
        try {
          const taskTags = task.tags();
          if (taskTags && taskTags.length > 0) {
            app.add(taskTags, { to: newTask.tags });
          }
        } catch (e) {}
        
        // Delete original task
        task.delete();
        
        // Update task reference for return data
        task = newTask;
      } catch (e) {
        throw new Error(`Failed to move task to inbox: ${e.message}`);
      }
    } else {
      // Move to specific project - with retry for newly created projects
      let targetProject = null;
      let projectAttempts = 0;
      const maxProjectAttempts = 3;
      
      while (projectAttempts < maxProjectAttempts && !targetProject) {
        try {
          targetProject = doc.flattenedProjects.byId(targetProjectId);
          if (targetProject && targetProject.id()) {
            break; // Found the project
          }
        } catch (e) {
          // Project not found, may need to wait for sync
        }
        
        projectAttempts++;
        if (projectAttempts < maxProjectAttempts) {
          // Wait 500ms before retry
          app.delay(0.5);
        }
      }
      
      if (!targetProject) {
        return JSON.stringify({
          error: true,
          message: `Target project not found after ${maxProjectAttempts} attempts: ${targetProjectId}`,
          code: 'NOT_FOUND'
        });
      }
      
      // Verify project has valid ID
      let projectId = null;
      try {
        projectId = targetProject.id();
      } catch (e) {
        return JSON.stringify({
          error: true,
          message: `Target project ID not accessible: ${targetProjectId}`,
          code: 'NOT_FOUND'
        });
      }
      
      if (!projectId) {
        return JSON.stringify({
          error: true,
          message: `Target project has no ID: ${targetProjectId}`,
          code: 'NOT_FOUND'
        });
      }
      
      try {
        // For all task moves, use the recreate and delete pattern
        // This is the most reliable approach in OmniFocus
        const taskProps = {
          name: task.name(),
          note: task.note() || '',
          flagged: task.flagged(),
          completed: task.completed()
        };
        
        // Copy optional properties if they exist
        try { if (task.dueDate()) taskProps.dueDate = task.dueDate(); } catch (e) {}
        try { if (task.deferDate()) taskProps.deferDate = task.deferDate(); } catch (e) {}
        try { if (task.estimatedMinutes()) taskProps.estimatedMinutes = task.estimatedMinutes(); } catch (e) {}
        try { if (task.completionDate()) taskProps.completionDate = task.completionDate(); } catch (e) {}
        
        // Create new task in project
        const newTask = app.Task(taskProps);
        targetProject.tasks.push(newTask);
        
        // Copy tags
        try {
          const taskTags = task.tags();
          if (taskTags && taskTags.length > 0) {
            app.add(taskTags, { to: newTask.tags });
          }
        } catch (e) {}
        
        // Delete original task
        task.delete();
        
        // Update task reference for return data
        task = newTask;
      } catch (e) {
        return JSON.stringify({
          error: true,
          message: `Failed to move task to project: ${e.message}`,
          code: 'SCRIPT_ERROR'
        });
      }
    }
    
    // Return updated task data - use try-catch for each property to handle conversion errors
    const result = {
      tags: [],
      projectId: null,
      parentTaskId: null,
      containingProjectInfo: null
    };
    
    try { result.id = task.id(); } catch (e) { result.id = null; }
    try { result.name = task.name(); } catch (e) { result.name = 'Unknown Task'; }
    try { result.note = task.note() || null; } catch (e) { result.note = null; }
    try { result.completed = task.completed(); } catch (e) { result.completed = false; }
    try { result.completionDate = task.completionDate() ? task.completionDate().toISOString() : null; } catch (e) { result.completionDate = null; }
    try { result.creationDate = task.creationDate() ? task.creationDate().toISOString() : null; } catch (e) { result.creationDate = null; }
    try { result.modificationDate = task.modificationDate() ? task.modificationDate().toISOString() : null; } catch (e) { result.modificationDate = null; }
    try { result.dueDate = task.dueDate() ? task.dueDate().toISOString() : null; } catch (e) { result.dueDate = null; }
    try { result.deferDate = task.deferDate() ? task.deferDate().toISOString() : null; } catch (e) { result.deferDate = null; }
    try { result.estimatedMinutes = task.estimatedMinutes() || null; } catch (e) { result.estimatedMinutes = null; }
    try { result.flagged = task.flagged(); } catch (e) { result.flagged = false; }
    try { result.repetitionRule = task.repetitionRule() ? task.repetitionRule().toString() : null; } catch (e) { result.repetitionRule = null; }
    
    // Get tags
    try {
      const taskTags = task.tags();
      if (taskTags && taskTags.length > 0) {
        for (let j = 0; j < taskTags.length; j++) {
          try {
            result.tags.push(taskTags[j].name());
          } catch (e) {
            // Skip this tag if conversion fails
          }
        }
      }
    } catch (e) {
      // Tags not accessible
    }
    
    // Get containing project
    try {
      const containingProject = task.containingProject();
      if (containingProject) {
        try { result.projectId = containingProject.id(); } catch (e) { }
        try {
          result.containingProjectInfo = {
            id: containingProject.id(),
            name: containingProject.name(),
            status: containingProject.status()
          };
        } catch (e) {
          // Project info might not be accessible
        }
      }
    } catch (e) {
      // Project info might not be accessible
    }
    
    return JSON.stringify(result);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();