(() => {
  'use strict';
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const taskId = {{taskId}};
    const updates = {{updates}};
    
    if (!taskId) {
      throw new Error('Task ID is required');
    }
    
    const doc = app.defaultDocument;
    
    // Find the task
    let task = null;
    try {
      task = doc.flattenedTasks.byId(taskId);
      if (!task || !task.id) {
        throw new Error('Task not found');
      }
    } catch (e) {
      return JSON.stringify({
        error: true,
        message: 'Task not found',
        code: 'NOT_FOUND'
      });
    }
    
    // Apply updates
    if (updates.name !== undefined) task.name = updates.name;
    if (updates.note !== undefined) task.note = updates.note;
    if (updates.flagged !== undefined) task.flagged = updates.flagged;
    if (updates.dueDate !== undefined) {
      if (updates.dueDate) {
        try {
          const dueDate = new Date(updates.dueDate);
          if (!isNaN(dueDate.getTime()) && dueDate.getFullYear() > 1970) {
            task.dueDate = dueDate;
          }
        } catch (e) {
          // Invalid date, skip setting
        }
      } else {
        task.dueDate = null;
      }
    }
    if (updates.deferDate !== undefined) {
      if (updates.deferDate) {
        try {
          const deferDate = new Date(updates.deferDate);
          if (!isNaN(deferDate.getTime()) && deferDate.getFullYear() > 1970) {
            task.deferDate = deferDate;
          }
        } catch (e) {
          // Invalid date, skip setting
        }
      } else {
        task.deferDate = null;
      }
    }
    if (updates.estimatedMinutes !== undefined) task.estimatedMinutes = updates.estimatedMinutes;
    if (updates.repetitionRule !== undefined) task.repetitionRule = updates.repetitionRule;
    
    // Return updated task data - use try-catch for each property to handle conversion errors
    const result = {};
    
    try { result.id = task.id; } catch (e) { result.id = null; }
    try { result.name = task.name; } catch (e) { result.name = 'Unknown Task'; }
    try { result.note = task.note || null; } catch (e) { result.note = null; }
    try { result.completed = task.completed; } catch (e) { result.completed = false; }
    try { result.completionDate = task.completionDate ? task.completionDate.toISOString() : null; } catch (e) { result.completionDate = null; }
    try { result.creationDate = task.creationDate ? task.creationDate.toISOString() : null; } catch (e) { result.creationDate = null; }
    try { result.modificationDate = task.modificationDate ? task.modificationDate.toISOString() : null; } catch (e) { result.modificationDate = null; }
    try { result.dueDate = task.dueDate ? task.dueDate.toISOString() : null; } catch (e) { result.dueDate = null; }
    try { result.deferDate = task.deferDate ? task.deferDate.toISOString() : null; } catch (e) { result.deferDate = null; }
    try { result.estimatedMinutes = task.estimatedMinutes || null; } catch (e) { result.estimatedMinutes = null; }
    try { result.flagged = task.flagged; } catch (e) { result.flagged = false; }
    try { result.repetitionRule = task.repetitionRule ? task.repetitionRule.toString() : null; } catch (e) { result.repetitionRule = null; }
    
    result.tags = [];
    result.projectId = null;
    result.parentTaskId = null;
    result.containingProjectInfo = null;
    
    // Get tags
    try {
      const taskTags = task.tags;
      if (taskTags && taskTags.length > 0) {
        for (let j = 0; j < taskTags.length; j++) {
          try {
            result.tags.push(taskTags[j].name);
          } catch (e) {
            // Skip this tag if conversion fails
          }
        }
      }
    } catch (e) {
      // Tags not accessible
    }
    
    // Get containing project
    try {
      const containingProject = task.containingProject;
      if (containingProject) {
        try { result.projectId = containingProject.id; } catch (e) { }
        try {
          result.containingProjectInfo = {
            id: containingProject.id,
            name: containingProject.name,
            status: containingProject.status
          };
        } catch (e) {
          // Project info might not be accessible
        }
      }
    } catch (e) {
      // Project info might not be accessible
    }
    
    return JSON.stringify(result);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();