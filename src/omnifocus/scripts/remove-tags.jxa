(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const itemId = {{itemId}};
    const tagIds = {{tagIds}};
    const itemType = {{itemType}};
    const doc = app.defaultDocument;
    
    // Find the item
    let item = null;
    try {
      if (itemType === 'task') {
        item = doc.flattenedTasks.byId(itemId);
      } else {
        item = doc.flattenedProjects.byId(itemId);
      }
      
      if (!item || !item.id()) {
        throw new Error('Item not found');
      }
    } catch (e) {
      return JSON.stringify({
        error: true,
        message: 'Item not found',
        code: 'NOT_FOUND'
      });
    }
    
    // Use Application.delete() method for tag removal
    let removedCount = 0;
    try {
      // Get existing tags
      const existingTags = [];
      try {
        const itemTags = item.tags();
        for (let i = 0; i < itemTags.length; i++) {
          existingTags.push(itemTags[i]);
        }
      } catch (e) {
        // No existing tags
        return JSON.stringify({ 
          success: true, 
          removedCount: 0,
          message: "No tags to remove"
        });
      }
      
      // Find tags to remove by ID
      const tagsToRemove = [];
      for (const tagId of tagIds) {
        for (const existingTag of existingTags) {
          try {
            if (existingTag.id() === tagId) {
              tagsToRemove.push(existingTag);
              break;
            }
          } catch (e) {
            // Skip invalid tags
          }
        }
      }
      
      // Remove tags using Application.delete() method
      if (tagsToRemove.length > 0) {
        for (const tagToRemove of tagsToRemove) {
          try {
            app.delete(tagToRemove, { from: item.tags });
            removedCount++;
          } catch (e) {
            // Skip tags that couldn't be removed
          }
        }
      }
      
    } catch (e) {
      throw new Error(`Failed to remove tags: ${e.message}`);
    }
    
    return JSON.stringify({ 
      success: true, 
      removedCount: removedCount,
      message: `Successfully removed ${removedCount} tag(s)`
    });
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();
