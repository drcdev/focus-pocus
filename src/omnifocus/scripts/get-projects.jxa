(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const doc = app.defaultDocument;
    const flattenedProjects = doc.flattenedProjects;
    
    const projects = [];
    
    for (let i = 0; i < flattenedProjects.length; i++) {
      const project = flattenedProjects[i];
      
      try {
        const projectData = {
          id: safeGet(project, 'id'),
          name: safeGet(project, 'name'),
          note: safeGet(project, 'note'),
          status: safeGet(project, 'status'),
          creationDate: safeDate(safeGet(project, 'creationDate')),
          modificationDate: safeDate(safeGet(project, 'modificationDate')),
          completionDate: safeDate(safeGet(project, 'completionDate')),
          dueDate: safeDate(safeGet(project, 'dueDate')),
          deferDate: safeDate(safeGet(project, 'deferDate')),
          estimatedMinutes: safeGet(project, 'estimatedMinutes'),
          flagged: safeGet(project, 'flagged', false),
          tags: [],
          folderId: null,
          taskCount: 0,
          completedTaskCount: 0,
          remainingTaskCount: 0,
          nextTaskId: null
        };
        
        // Get tags
        const projectTags = safeGet(project, 'tags');
        if (projectTags && projectTags.length > 0) {
          for (let j = 0; j < projectTags.length; j++) {
            const tagName = safeGet(projectTags[j], 'name');
            if (tagName) {
              projectData.tags.push(tagName);
            }
          }
        }
        
        // Get containing folder
        const containingFolder = safeGet(project, 'folder');
        if (containingFolder) {
          projectData.folderId = safeGet(containingFolder, 'id');
        }
        
        // Get task counts
        const tasks = safeGet(project, 'tasks');
        if (tasks) {
          projectData.taskCount = tasks.length;
          
          let completedCount = 0;
          for (let k = 0; k < tasks.length; k++) {
            if (safeGet(tasks[k], 'completed', false)) {
              completedCount++;
            }
          }
          
          projectData.completedTaskCount = completedCount;
          projectData.remainingTaskCount = projectData.taskCount - completedCount;
        }
        
        // Get next task
        const nextTask = safeGet(project, 'nextTask');
        if (nextTask) {
          projectData.nextTaskId = safeGet(nextTask, 'id');
        }
        
        projects.push(projectData);
      } catch (projectError) {
        // Skip individual project errors but continue processing
        console.log('Error processing project:', projectError.message);
      }
    }
    
    return JSON.stringify(projects);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();