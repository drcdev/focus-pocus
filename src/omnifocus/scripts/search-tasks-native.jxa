(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // Direct property access is faster and more reliable in OmniFocus 4
      const value = obj[prop];
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      return defaultValue;
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const options = {
      query: {{query}} || null,
      projectId: {{projectId}} || null,
      tagId: {{tagId}} || null,
      completed: {{completed}} !== undefined ? {{completed}} : null,
      flagged: {{flagged}} !== undefined ? {{flagged}} : null,
      status: {{status}} || null,
      dueBefore: {{dueBefore}} ? new Date({{dueBefore}}) : null,
      dueAfter: {{dueAfter}} ? new Date({{dueAfter}}) : null,
      createdBefore: {{createdBefore}} ? new Date({{createdBefore}}) : null,
      createdAfter: {{createdAfter}} ? new Date({{createdAfter}}) : null,
      limit: {{limit}} || 25,
      offset: {{offset}} || 0
    };
    
    const doc = app.defaultDocument;
    
    // Build native filter object for maximum OmniFocus performance
    let filterObj = {};
    
    // Text search in name
    if (options.query) {
      filterObj.name = {_contains: options.query};
    }
    
    // Completion status
    if (options.completed !== null) {
      filterObj.completed = options.completed;
    }
    
    // Status enum handling
    if (options.status) {
      switch (options.status) {
        case 'available':
          filterObj.completed = false;
          filterObj.dropped = false;
          break;
        case 'completed':
          filterObj.completed = true;
          break;
        case 'dropped':
          filterObj.dropped = true;
          break;
      }
    }
    
    // Flagged status
    if (options.flagged !== null) {
      filterObj.flagged = options.flagged;
    }
    
    // Skip complex date filtering in initial query for performance
    // Manual date filtering will be applied later to reduce processing overhead
    
    // Get filtered tasks using native OmniFocus filtering
    let filteredTasks;
    
    if (options.projectId) {
      // Special handling for inbox
      if (options.projectId === 'inbox') {
        // Get inbox tasks directly
        filteredTasks = Object.keys(filterObj).length > 0 
          ? doc.inboxTasks.whose(filterObj)
          : doc.inboxTasks();
      } else {
        // Search within specific project
        const projects = doc.flattenedProjects;
        let targetProject = null;
        
        for (let i = 0; i < projects.length; i++) {
          try {
            let projectId;
            try {
              projectId = projects[i].id();
            } catch (e) {
              projectId = projects[i].id;
            }
            if (projectId === options.projectId) {
              targetProject = projects[i];
              break;
            }
          } catch (e) {
            continue;
          }
        }
        
        if (!targetProject) {
          return JSON.stringify([]);
        }
        
        // Use tasks property for direct project tasks, flattenedTasks for all tasks including subtasks
        filteredTasks = Object.keys(filterObj).length > 0 
          ? targetProject.tasks.whose(filterObj)
          : targetProject.tasks();
      }
    } else {
      // Search all tasks
      filteredTasks = Object.keys(filterObj).length > 0 
        ? doc.flattenedTasks.whose(filterObj)
        : doc.flattenedTasks();
    }
    
    // Apply manual filtering with performance limits
    let dateFilteredTasks = [];
    const maxTasksToProcess = 1000; // Limit processing to prevent timeouts
    const maxTasksToCheck = Math.min(filteredTasks.length, maxTasksToProcess);
    
    for (let i = 0; i < maxTasksToCheck; i++) {
      const task = filteredTasks[i];
      let includeTask = true;
      
      // Manual date filtering - exclude tasks without due dates when date filtering is requested
      if (options.dueBefore || options.dueAfter) {
        try {
          let dueDate;
          try {
            dueDate = task.dueDate();
          } catch (e) {
            dueDate = task.dueDate;
          }
          
          // If no due date and we're filtering by date, exclude the task
          if (!dueDate) {
            includeTask = false;
          } else {
            if (options.dueBefore) {
              const beforeDate = new Date(options.dueBefore);
              // Ensure valid date comparison
              if (!isNaN(beforeDate.getTime()) && dueDate >= beforeDate) includeTask = false;
            }
            if (options.dueAfter) {
              const afterDate = new Date(options.dueAfter);
              // Ensure valid date comparison  
              if (!isNaN(afterDate.getTime()) && dueDate <= afterDate) includeTask = false;
            }
          }
        } catch (e) {
          // If date comparison fails, exclude the task when date filtering is requested
          includeTask = false;
        }
      }
      
      if (includeTask) {
        dateFilteredTasks.push(task);
      }
      
      // Early exit if we have enough results or processing too many tasks
      if (dateFilteredTasks.length >= (options.offset + options.limit)) {
        break;
      }
      
      // For date ranges (both dueBefore and dueAfter), limit processing to prevent timeout
      if (options.dueBefore && options.dueAfter && i > 500) {
        break; // Limit combined date range searches to 500 tasks to prevent timeout
      }
    }
    
    // Apply pagination and extract minimal data for maximum speed
    const startIndex = options.offset;
    const endIndex = Math.min(startIndex + options.limit, dateFilteredTasks.length);
    const results = [];
    
    for (let i = startIndex; i < endIndex; i++) {
      const task = dateFilteredTasks[i];
      
      try {
        // Only extract essential data to minimize JXA overhead - use safe property access
        const taskData = {
          tags: [],
          projectId: null,
          note: null,
          dueDate: null
        };
        
        try { 
          const taskId = task.id();
          if (taskId) taskData.id = taskId;
        } catch (e) { 
          try {
            const taskId = task.id;
            if (taskId) taskData.id = taskId;
          } catch (e2) { taskData.id = null; }
        }
        try { 
          const taskName = task.name();
          if (taskName) taskData.name = taskName;
        } catch (e) { 
          try {
            const taskName = task.name;
            if (taskName) taskData.name = taskName;
          } catch (e2) { taskData.name = 'Unknown Task'; }
        }
        try { 
          const isCompleted = task.completed();
          taskData.completed = isCompleted;
        } catch (e) { 
          try {
            const isCompleted = task.completed;
            taskData.completed = isCompleted;
          } catch (e2) { taskData.completed = false; }
        }
        try { 
          const isFlagged = task.flagged();
          taskData.flagged = isFlagged;
        } catch (e) { 
          try {
            const isFlagged = task.flagged;
            taskData.flagged = isFlagged;
          } catch (e2) { taskData.flagged = false; }
        }
        
        // Add optional data only if needed/accessible
        try { 
          let taskNote;
          try {
            taskNote = task.note();
          } catch (e) {
            taskNote = task.note;
          }
          taskData.note = taskNote || null;
        } catch (e) { }
        
        try { 
          let dueDate;
          try {
            dueDate = task.dueDate();
          } catch (e) {
            dueDate = task.dueDate;
          }
          taskData.dueDate = dueDate ? dueDate.toISOString() : null;
        } catch (e) { }
        
        // Project info (only if not already filtered by project)
        if (!options.projectId) {
          try {
            const containingProject = task.containingProject;
            if (containingProject) {
              try { taskData.projectId = containingProject.id; } catch (e) { 
                try { taskData.projectId = containingProject.id(); } catch (e2) { /* Skip project ID if conversion fails */ }
              }
            }
          } catch (e) { /* Skip project info if conversion fails */ }
        } else {
          taskData.projectId = options.projectId;
        }
        
        // Tags (limited for performance)
        try {
          let taskTags;
          try {
            taskTags = task.tags();
          } catch (e) {
            taskTags = task.tags;
          }
          
          if (taskTags && taskTags.length > 0) {
            for (let j = 0; j < Math.min(taskTags.length, 3); j++) {
              try {
                let tagName;
                try {
                  tagName = taskTags[j].name();
                } catch (e) {
                  tagName = taskTags[j].name;
                }
                if (tagName) taskData.tags.push(tagName);
              } catch (e) { }
            }
          }
        } catch (e) { }
        
        // Tag filtering (if specified) - simplified approach
        if (options.tagId) {
          let hasTag = false;
          try {
            let taskTags;
            try {
              taskTags = task.tags();
            } catch (e) {
              taskTags = task.tags;
            }
            
            if (taskTags && taskTags.length > 0) {
              for (let j = 0; j < taskTags.length && !hasTag; j++) {
                try {
                  // Try ID match first
                  let tagId;
                  try {
                    tagId = taskTags[j].id();
                  } catch (e) {
                    tagId = taskTags[j].id;
                  }
                  
                  if (tagId === options.tagId) {
                    hasTag = true;
                    break;
                  }
                  
                  // Also try name match as fallback
                  let tagName;
                  try {
                    tagName = taskTags[j].name();
                  } catch (e) {
                    tagName = taskTags[j].name;
                  }
                  
                  if (tagName === options.tagId) {
                    hasTag = true;
                    break;
                  }
                } catch (e) {
                  // Continue with next tag
                  continue;
                }
              }
            }
          } catch (e) { 
            // If tag access fails, include the task (don't filter out)
            hasTag = true;
          }
          
          if (!hasTag) {
            continue; // Skip this task if it doesn't have the required tag
          }
        }
        
        results.push(taskData);
        
      } catch (e) {
        // Skip tasks that can't be processed
        continue;
      }
    }
    
    return JSON.stringify(results);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();