(() => {
  'use strict';
  
  // Utility function for safe property access - eliminates redundant try-catch blocks
  function safeGet(obj, prop, defaultValue = null) {
    try {
      // OmniFocus 4 requires function call syntax for property access
      const value = obj[prop]();
      return value !== undefined ? value : defaultValue;
    } catch (e) {
      // Fallback to direct property access for compatibility
      try {
        const directValue = obj[prop];
        return directValue !== undefined ? directValue : defaultValue;
      } catch (e2) {
        return defaultValue;
      }
    }
  }
  
  // Utility function for safe date conversion
  function safeDate(dateValue) {
    if (!dateValue) return null;
    try {
      return dateValue.toISOString();
    } catch (e) {
      return null;
    }
  }
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    // Parse parameters with defaults for pagination
    const limit = {{limit}} || 25; // Default to 25 tasks per request for performance
    const offset = {{offset}} || 0;
    const includeCompleted = {{includeCompleted}} !== undefined ? {{includeCompleted}} : false;
    
    const doc = app.defaultDocument;
    const flattenedTasks = doc.flattenedTasks;
    
    const tasks = [];
    let processedCount = 0;
    let addedCount = 0;
    let totalCount = 0;
    
    // Use efficient iteration - don't access .length property which is expensive
    // Instead, iterate through collection and stop when we have enough
    for (let i = 0; addedCount < limit && i < 10000; i++) { // Safety limit to prevent infinite loops
      let task;
      try {
        task = flattenedTasks[i];
        if (!task) break; // End of collection reached
        
        // Count total tasks we've seen
        totalCount++;
        
        // Skip completed tasks if not requested
        if (!includeCompleted) {
          const isCompleted = safeGet(task, 'completed', false);
          if (isCompleted) continue;
        }
        
        // Apply offset - skip tasks until we reach the desired offset
        if (processedCount < offset) {
          processedCount++;
          continue;
        }
        
      } catch (e) {
        // End of collection or access error
        break;
      }
      
      try {
        
        // Build minimal task data for performance - using utility functions
        const taskData = {
          id: safeGet(task, 'id'),
          name: safeGet(task, 'name', 'Unknown Task'),
          completed: safeGet(task, 'completed', false),
          flagged: safeGet(task, 'flagged', false)
        };
        
        // Only add optional fields if they exist (reduce JXA calls)
        const dueDate = safeGet(task, 'dueDate');
        if (dueDate) {
          const isoDate = safeDate(dueDate);
          if (isoDate) taskData.dueDate = isoDate;
        }
        
        const deferDate = safeGet(task, 'deferDate');
        if (deferDate) {
          const isoDate = safeDate(deferDate);
          if (isoDate) taskData.deferDate = isoDate;
        }
        
        const estimatedMinutes = safeGet(task, 'estimatedMinutes');
        if (estimatedMinutes) {
          taskData.estimatedMinutes = estimatedMinutes;
        }
        
        // Get project ID only if task has a containing project
        const containingProject = safeGet(task, 'containingProject');
        if (containingProject) {
          const projectId = safeGet(containingProject, 'id');
          if (projectId) taskData.projectId = projectId;
        }
        
        tasks.push(taskData);
        processedCount++;
        addedCount++;
        
      } catch (taskError) {
        // Skip individual task errors but continue processing
        continue;
      }
    }
    
    // For pagination info, we can't efficiently determine total without expensive operations
    // So we indicate hasMore based on whether we reached our limit
    const hasMore = addedCount === limit;
    
    return JSON.stringify({
      tasks: tasks,
      pagination: {
        offset: offset,
        limit: limit,
        returned: tasks.length,
        hasMore: hasMore,
        note: "Total count omitted for performance - use hasMore for pagination"
      }
    });
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();