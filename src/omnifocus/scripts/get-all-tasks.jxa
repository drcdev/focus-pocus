(() => {
  'use strict';
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    // Parse parameters with defaults for pagination
    const limit = {{limit}} || 25; // Default to 25 tasks per request for performance
    const offset = {{offset}} || 0;
    const includeCompleted = {{includeCompleted}} !== undefined ? {{includeCompleted}} : false;
    
    const doc = app.defaultDocument;
    const flattenedTasks = doc.flattenedTasks;
    
    const tasks = [];
    let processedCount = 0;
    let addedCount = 0;
    
    for (let i = 0; i < flattenedTasks.length && addedCount < limit; i++) {
      const task = flattenedTasks[i];
      
      try {
        // Skip completed tasks if not requested
        if (!includeCompleted && task.completed()) {
          continue;
        }
        
        // Apply offset
        if (processedCount < offset) {
          processedCount++;
          continue;
        }
        
        // Build minimal task data for performance - only essential fields
        const taskData = {
          id: task.id(),
          name: task.name(),
          completed: task.completed(),
          flagged: task.flagged()
        };
        
        // Only add optional fields if they exist (reduce JXA calls)
        const dueDate = task.dueDate();
        if (dueDate) {
          taskData.dueDate = dueDate.toISOString();
        }
        
        const deferDate = task.deferDate();
        if (deferDate) {
          taskData.deferDate = deferDate.toISOString();
        }
        
        const estimatedMinutes = task.estimatedMinutes();
        if (estimatedMinutes) {
          taskData.estimatedMinutes = estimatedMinutes;
        }
        
        // Get project ID only if task has a containing project
        const containingProject = task.containingProject();
        if (containingProject) {
          taskData.projectId = containingProject.id();
        }
        
        tasks.push(taskData);
        processedCount++;
        addedCount++;
        
      } catch (taskError) {
        // Skip individual task errors but continue processing
        continue;
      }
    }
    
    return JSON.stringify({
      tasks: tasks,
      pagination: {
        total: flattenedTasks.length,
        offset: offset,
        limit: limit,
        returned: tasks.length,
        hasMore: (offset + tasks.length) < flattenedTasks.length
      }
    });
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();