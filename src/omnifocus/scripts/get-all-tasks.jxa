(() => {
  'use strict';
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    // Parse parameters with defaults for pagination
    const limit = {{limit}} || 25; // Default to 25 tasks per request for performance
    const offset = {{offset}} || 0;
    const includeCompleted = {{includeCompleted}} !== undefined ? {{includeCompleted}} : false;
    
    const doc = app.defaultDocument;
    const flattenedTasks = doc.flattenedTasks;
    
    const tasks = [];
    let processedCount = 0;
    let addedCount = 0;
    
    for (let i = 0; i < flattenedTasks.length && addedCount < limit; i++) {
      const task = flattenedTasks[i];
      
      try {
        // Skip completed tasks if not requested
        if (!includeCompleted) {
          try {
            const isCompleted = task.completed();
            if (isCompleted) continue;
          } catch (e) {
            try {
              const isCompleted = task.completed;
              if (isCompleted) continue;
            } catch (e2) {
              // If we can't determine completion status, include the task
            }
          }
        }
        
        // Apply offset
        if (processedCount < offset) {
          processedCount++;
          continue;
        }
        
        // Build minimal task data for performance - safe property access
        const taskData = {};
        
        try { 
          const taskId = task.id();
          if (taskId) taskData.id = taskId;
        } catch (e) { 
          // If id() fails, try accessing as property
          try {
            const taskId = task.id;
            if (taskId) taskData.id = taskId;
          } catch (e2) { taskData.id = null; }
        }
        try { 
          const taskName = task.name();
          if (taskName) taskData.name = taskName;
        } catch (e) { 
          try {
            const taskName = task.name;
            if (taskName) taskData.name = taskName;
          } catch (e2) { taskData.name = 'Unknown Task'; }
        }
        try { 
          const isCompleted = task.completed();
          taskData.completed = isCompleted;
        } catch (e) { 
          try {
            const isCompleted = task.completed;
            taskData.completed = isCompleted;
          } catch (e2) { taskData.completed = false; }
        }
        try { 
          const isFlagged = task.flagged();
          taskData.flagged = isFlagged;
        } catch (e) { 
          try {
            const isFlagged = task.flagged;
            taskData.flagged = isFlagged;
          } catch (e2) { taskData.flagged = false; }
        }
        
        // Only add optional fields if they exist (reduce JXA calls)
        try {
          const dueDate = task.dueDate;
          if (dueDate) {
            taskData.dueDate = dueDate.toISOString();
          }
        } catch (e) { /* Skip due date if conversion fails */ }
        
        try {
          const deferDate = task.deferDate;
          if (deferDate) {
            taskData.deferDate = deferDate.toISOString();
          }
        } catch (e) { /* Skip defer date if conversion fails */ }
        
        try {
          const estimatedMinutes = task.estimatedMinutes;
          if (estimatedMinutes) {
            taskData.estimatedMinutes = estimatedMinutes;
          }
        } catch (e) { /* Skip estimated minutes if conversion fails */ }
        
        // Get project ID only if task has a containing project
        try {
          const containingProject = task.containingProject;
          if (containingProject) {
            try { taskData.projectId = containingProject.id; } catch (e) { /* Skip project ID if conversion fails */ }
          }
        } catch (e) { /* Skip project info if conversion fails */ }
        
        tasks.push(taskData);
        processedCount++;
        addedCount++;
        
      } catch (taskError) {
        // Skip individual task errors but continue processing
        continue;
      }
    }
    
    return JSON.stringify({
      tasks: tasks,
      pagination: {
        total: flattenedTasks.length,
        offset: offset,
        limit: limit,
        returned: tasks.length,
        hasMore: (offset + tasks.length) < flattenedTasks.length
      }
    });
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();