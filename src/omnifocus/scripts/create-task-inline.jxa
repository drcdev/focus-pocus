(() => {
  'use strict';
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const options = {{options}};
    const doc = app.defaultDocument;
    
    // Build task properties
    const taskProps = {
      name: options.name
    };
    
    if (options.note) taskProps.note = options.note;
    if (options.flagged !== undefined) taskProps.flagged = options.flagged;
    if (options.dueDate) taskProps.dueDate = new Date(options.dueDate);
    if (options.deferDate) taskProps.deferDate = new Date(options.deferDate);
    if (options.estimatedMinutes) taskProps.estimatedMinutes = options.estimatedMinutes;
    if (options.repetitionRule) taskProps.repetitionRule = options.repetitionRule;
    
    // Create the task
    const task = app.Task(taskProps);
    doc.inboxTasks.push(task);
    
    // Handle project assignment if specified
    if (options.projectId) {
      try {
        const project = doc.flattenedProjects.byId(options.projectId);
        if (project) {
          task.assignedContainer = project;
        }
      } catch (e) {
        // Project not found, leave in inbox
      }
    }
    
    // Handle tag assignment if specified
    if (options.tags && options.tags.length > 0) {
      try {
        const tags = [];
        for (const tagId of options.tags) {
          const tag = doc.flattenedTags.byId(tagId);
          if (tag) tags.push(tag);
        }
        if (tags.length > 0) {
          task.tags = tags;
        }
      } catch (e) {
        // Tags not found, continue without them
      }
    }
    
    // Return task data
    const result = {
      id: task.id(),
      name: task.name(),
      note: task.note() || null,
      completed: task.completed(),
      completionDate: task.completionDate() ? task.completionDate().toISOString() : null,
      creationDate: task.creationDate().toISOString(),
      modificationDate: task.modificationDate().toISOString(),
      dueDate: task.dueDate() ? task.dueDate().toISOString() : null,
      deferDate: task.deferDate() ? task.deferDate().toISOString() : null,
      estimatedMinutes: task.estimatedMinutes() || null,
      flagged: task.flagged(),
      repetitionRule: task.repetitionRule() ? task.repetitionRule().toString() : null,
      tags: [],
      projectId: null,
      parentTaskId: null,
      containingProjectInfo: null
    };
    
    // Get tags
    const taskTags = task.tags();
    if (taskTags && taskTags.length > 0) {
      for (let j = 0; j < taskTags.length; j++) {
        result.tags.push(taskTags[j].name());
      }
    }
    
    // Get containing project
    try {
      const containingProject = task.containingProject();
      if (containingProject) {
        result.projectId = containingProject.id();
        result.containingProjectInfo = {
          id: containingProject.id(),
          name: containingProject.name(),
          status: containingProject.status()
        };
      }
    } catch (e) {
      // Project info might not be accessible
    }
    
    return JSON.stringify(result);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();