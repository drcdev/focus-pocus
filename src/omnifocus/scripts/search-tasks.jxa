(() => {
  'use strict';
  
  try {
    const app = Application('OmniFocus');
    app.includeStandardAdditions = true;
    
    if (!app.running()) {
      throw new Error('OmniFocus is not running');
    }
    
    const options = {
      query: {{query}} || null,
      projectId: {{projectId}} || null,
      folderId: {{folderId}} || null,
      tagIds: {{tagIds}} || [],
      completed: {{completed}} !== undefined ? {{completed}} : null,
      flagged: {{flagged}} !== undefined ? {{flagged}} : null,
      dueBefore: {{dueBefore}} ? new Date({{dueBefore}}) : null,
      dueAfter: {{dueAfter}} ? new Date({{dueAfter}}) : null,
      createdBefore: {{createdBefore}} ? new Date({{createdBefore}}) : null,
      createdAfter: {{createdAfter}} ? new Date({{createdAfter}}) : null,
      limit: {{limit}} || null,
      offset: {{offset}} || 0
    };
    
    const doc = app.defaultDocument;
    const flattenedTasks = doc.flattenedTasks;
    
    const matchingTasks = [];
    let processedCount = 0;
    
    for (let i = 0; i < flattenedTasks.length; i++) {
      const task = flattenedTasks[i];
      
      try {
        // Apply filters
        if (options.completed !== null && task.completed() !== options.completed) {
          continue;
        }
        
        if (options.flagged !== null && task.flagged() !== options.flagged) {
          continue;
        }
        
        if (options.projectId) {
          const containingProject = task.containingProject();
          if (!containingProject || containingProject.id() !== options.projectId) {
            continue;
          }
        }
        
        if (options.query) {
          const taskName = task.name().toLowerCase();
          const taskNote = (task.note() || '').toLowerCase();
          const searchQuery = options.query.toLowerCase();
          
          if (!taskName.includes(searchQuery) && !taskNote.includes(searchQuery)) {
            continue;
          }
        }
        
        if (options.dueBefore && task.dueDate()) {
          if (task.dueDate() >= options.dueBefore) {
            continue;
          }
        }
        
        if (options.dueAfter && task.dueDate()) {
          if (task.dueDate() <= options.dueAfter) {
            continue;
          }
        }
        
        if (options.createdBefore) {
          if (task.creationDate() >= options.createdBefore) {
            continue;
          }
        }
        
        if (options.createdAfter) {
          if (task.creationDate() <= options.createdAfter) {
            continue;
          }
        }
        
        // Tag filtering
        if (options.tagIds && options.tagIds.length > 0) {
          const taskTags = task.tags();
          let hasMatchingTag = false;
          
          if (taskTags && taskTags.length > 0) {
            for (let j = 0; j < taskTags.length; j++) {
              if (options.tagIds.includes(taskTags[j].id())) {
                hasMatchingTag = true;
                break;
              }
            }
          }
          
          if (!hasMatchingTag) {
            continue;
          }
        }
        
        // Apply offset
        if (processedCount < options.offset) {
          processedCount++;
          continue;
        }
        
        // Apply limit
        if (options.limit && matchingTasks.length >= options.limit) {
          break;
        }
        
        // Build task data
        const taskData = {
          id: task.id(),
          name: task.name(),
          note: task.note() || null,
          completed: task.completed(),
          completionDate: task.completionDate() ? task.completionDate().toISOString() : null,
          creationDate: task.creationDate().toISOString(),
          modificationDate: task.modificationDate().toISOString(),
          dueDate: task.dueDate() ? task.dueDate().toISOString() : null,
          deferDate: task.deferDate() ? task.deferDate().toISOString() : null,
          estimatedMinutes: task.estimatedMinutes() || null,
          flagged: task.flagged(),
          repetitionRule: task.repetitionRule() ? task.repetitionRule().toString() : null,
          tags: [],
          projectId: null,
          parentTaskId: null,
          containingProjectInfo: null
        };
        
        // Get tags
        const taskTags = task.tags();
        if (taskTags && taskTags.length > 0) {
          for (let j = 0; j < taskTags.length; j++) {
            taskData.tags.push(taskTags[j].name());
          }
        }
        
        // Get containing project
        const containingProject = task.containingProject();
        if (containingProject) {
          taskData.projectId = containingProject.id();
          taskData.containingProjectInfo = {
            id: containingProject.id(),
            name: containingProject.name(),
            status: containingProject.status()
          };
        }
        
        // Get parent task
        const parentTask = task.parentTask();
        if (parentTask) {
          taskData.parentTaskId = parentTask.id();
        }
        
        matchingTasks.push(taskData);
        processedCount++;
        
      } catch (taskError) {
        // Skip individual task errors but continue processing
        console.log('Error processing task:', taskError.message);
      }
    }
    
    return JSON.stringify(matchingTasks);
    
  } catch (error) {
    return JSON.stringify({
      error: true,
      message: error.message,
      code: 'SCRIPT_ERROR'
    });
  }
})();